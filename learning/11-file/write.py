#!/usr/bin/env python  
# -*- coding: utf-8 -*-

"""
------------------------------------------------------------------------------------------------------------------------

@Author: Bamboo
@Email: bamboo8493@126.com
@Datetime: 2019/8/22 9:53
@Description: 文件清空后再写操作

------------------------------------------------------------------------------------------------------------------------

@Modifier: 
@Email: 
@Datetime: 2019/8/22 9:53
@Description: 

------------------------------------------------------------------------------------------------------------------------
"""

# open 打开文件，第一个参数：文件路径，第二个参数：模式（w清空写），第三个参数：读取编码
# 以写模式打开文件时，如果文件存在，则清空文件内容，如果文件不存在，则创建新文件
file = open('write.txt', 'w', encoding='utf-8')
# 获取文件描述符 => 整数
# print(file.fileno())
# 读取文件，参数：要写进文件的数据
file.write('hello world!\n')
file.write('I am Bamboo')

#flush() 方法是用来刷新缓冲区的，即将缓冲区中的数据立刻写入文件，同时清空缓冲区，不需要是被动的等待输出缓冲区写入。
# 一般情况下，文件关闭后会自动刷新缓冲区，但有时你需要在关闭前刷新它，这时就可以使用 flush() 方法。
# file.flush()
"""
#进度条实例
import sys,time
for i in range(30):
    # sys.stdout.write("*")
    # sys.stdout.flush()
    
    # print 方式
    # print('*',end='',flush=True)
    time.sleep(0.1)
"""

# truncate() 方法用于截断文件，如果指定了可选参数 size，则表示截断文件为 size 个字符。
# 如果没有指定 size，则从当前位置起截断；截断之后 size 后面的所有字符被删除
# 所以文件的打开方式必须可写，但是不能用w或w+等方式打开，因为那样直接清空文件了，所以truncate要在r+或a或a+等模式下测试效果
# file.truncate(5) # 截断掉从第5个字符开始后面的所有字符


# r+:光标默认在0位置，最后位置开始写
# w+:先清空，再写读
# a+:光标默认在最后位置

# 文件的数据是存放于硬盘上的，因而只存在覆盖、不存在修改这么一说，
# 我们平时看到的修改文件，都是模拟出来的效果，具体的说有两种实现方式：
# 方式一：将硬盘存放的该文件的内容全部加载到内存，在内存中是可以修改的，修改完毕后，再由内存覆盖到硬盘
# file.readlines()
# 方式二：将硬盘存放的该文件的内容一行一行地读入内存，修改完毕就写入新文件，最后用新文件覆盖源文件
# for line in file:

# 关闭文件
file.close()